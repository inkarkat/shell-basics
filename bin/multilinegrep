#!/bin/bash
set -o noglob
IFS=$'\n'

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" '[-E|--extended-regexp] [-F|--fixed-strings] [-G|--basic-regexp] [-e|--regexp] PATTERN [-e ...] [-x|--line-regexp] [-q|--quiet|--silent] [--line-buffered] [--] [FILE ...] [-?|-h|--help]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 '\nTry %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Searches the named input FILEs / standard input for lines containing a match to
the given PATTERN, which can go over multiple lines, and print the matching
lines.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    echo
    cat <<HELPTEXT

HELPTEXT
}

hasMatchMode=
assertSingleMatchMode()
{
    if [ "$hasMatchMode" ]; then
	echo 'ERROR: Only one of -E|--extended-regexp, -F|--fixed-strings, -G|--basic-regexp can be passed.'
	echo
	printUsage "$1"
	exit 2
    fi >&2
}

isLiteral=
isEntireLine=
startOfLineAssertion=''
isQuiet=
typeset -a patterns=()
typeset -a sedArgs=()
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)		shift; printLongUsage "$0"; exit 0;;
	--extended-regexp|-E)	shift; assertSingleMatchMode "$0"; hasMatchMode=t; sedArgs+=(--regexp-extended);;
	--fixed-strings|-F)	shift; assertSingleMatchMode "$0"; hasMatchMode=t; isLiteral=t;;
	--basic-regexp|-G)	shift; assertSingleMatchMode "$0"; hasMatchMode=t;;
	--regexp|-e)		shift; patterns+=("${1:?}"); shift;;
	--line-regexp|-x)	shift; isEntireLine=t; startOfLineAssertion='^';;
	--quiet|--silent|-q)	shift; isQuiet=t;;
	--line-buffered)	shift; sedArgs+=(--unbuffered);;
	--)			sedArgs+=("$1"); shift; break;;
	-*)			{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)			if [ ${#patterns[@]} -eq 0 ]; then
				    patterns+=("${1:?}")
				    shift
				fi
				break
				;;
    esac
done
if [ ${#patterns[@]} -eq 0 ]; then
    printUsage "$0" >&2
    exit 2
fi

typeset -a sedProgram=()
for pattern in "${patterns[@]}"
do
    if [ "$isLiteral" ]; then
	escapedPattern="$(printf %s "$pattern" | sed -e 's/[][\$*.^/]/\\&/g')"
    else
	escapedPattern="${pattern//\//\\/}"
    fi

    typeset -a lines=($escapedPattern)
    endOfFirstLineAssertion=''; [ "$isEntireLine" ] && [ ${#lines[@]} -eq 1 ] && endOfFirstLineAssertion='$'
    sedProgram+=(-e "/${startOfLineAssertion}${lines[0]}${endOfFirstLineAssertion}/{")
    lines=("${lines[@]:1}")

    while [ ${#lines[@]} -gt 0 ]
    do
	endOfLastLineAssertion=''
	if [ ${#lines[@]} -eq 1 ]; then
	    [ "$isEntireLine" ] || endOfLastLineAssertion='[^\n]*'
	fi
	line="${lines[0]}"; lines=("${lines[@]:1}")
	sedProgram+=(-e "N; /\\n${line}${endOfLastLineAssertion}$/!D")
    done

    sedProgram+=(-e 'h; p; b }')    # Non-empty hold space signals we've found a match.
done

exec sed -n "${sedArgs[@]}" "${sedProgram[@]}" -e '${ g; /^$/q 1 }' "$@"
