#!/bin/bash
set -o pipefail

printShortUsage()
{
    # Note: short followed by long option; if the user knows the short one, she can
    # skim the long one.
    printf 'Usage: %q %s\n' "$(basename "$1")" '-g|--greater|-s|--smaller|-lt|-le|-eq|-ne|-ge|-gt N -b|--bytes|-m|--chars|-l|--lines|-w|--words [-t|--tee] [--] FILE [...] [-?|-h|--help]'
    printf 'Usage: cat FILE [...] | %q %s\n' "$(basename "$1")" '-g|--greater|-s|--smaller|-lt|-le|-eq|-ne|-ge|-gt N [...] -'
    echo
    printf 'Usage: %q %s\n' "$(basename "$1")" '-g|--greater|-s|--smaller|-lt|-le|-eq|-ne|-ge|-gt N [...] -c|--command "COMMANDLINE" [...] | --exec SIMPLECOMMAND [...] ; [...] [-?|-h|--help]'
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments.
    # It is printed to stderr to avoid accidental processing.
    printShortUsage "$1" >&2
    printf >&2 '\nTry %q --help for more information.\n' "$(basename "$1")"
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument.
    # It is printed to stdout to allow paging with 'more'.
    cat <<HELPDESCRIPTION
Test whether the number of bytes / characters / lines / words in [all] FILE[s] /
produced by COMMAND is greater / smaller than N.
HELPDESCRIPTION
    echo
    printShortUsage "$1"
    echo
    cat <<HELPTEXT
    --bytes|-b		Count bytes.
    --chars|-m		Count characters.
    --lines|-l		Count newlines (default).
    --words|-w		Count words.
    --tee|-t		Keep outputting the input, too.
    --command|-c CMD	Execute CMD as a command-line.
    --exec CMD [...] ;	Execute CMD; all following arguments are taken to be
			arguments to the CMD until an argument consisting of ';'
			is encountered.
EXIT STATUS:
    0	Complete success.
    1	The comparison failed.
    2	Bad invocation, wrong or missing command-line arguments.
    4	Some of the passed FILE(s) do not exist, or execution of COMMAND failed.
HELPTEXT
}

num=
compareOp=
counter=getCount
typeset -a wcArg=(--lines)
typeset -a commands=()
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printLongUsage "$0"; exit 0;;
	--bytes|--chars|-m|--lines|-l|--words|-w)
			wcArg=("$1"); shift;;
	-b)		shift; wcArg=(--bytes);;
	--greater|-g)	shift; num="${1:?}"; shift; compareOp=-gt;;
	--smaller|-s)	shift; num="${1:?}"; shift; compareOp=-lt;;
	-lt|-le|-eq|-ne|-ge|-gt)
			compareOp="$1"; shift; num="${1:?}"; shift;;
	--tee|-t)	shift
			counter=getTeedCount
			exec 3>&1
			;;
	--command|-c)	shift; commands+=(${commands:+;} "$1"); shift;;
	--exec)		shift
			cmd=
			while [ $# -gt 0 -a "$1" != ';' ]
			do
			    printf -v quotedArg '%q' "$1"
			    cmd="${cmd}${cmd:+ }${quotedArg}"
			    shift
			done
			if [ $# -eq 0 ]; then
			    echo 'ERROR: --exec command must be concluded with ;!'; echo; printUsage "$0"
			    exit 2
			fi >&2
			shift
			commands+=(${commands:+;} "$cmd")
			;;
	--)		shift; break;;
	-)		break;; # For supporting special - FILE without prior --
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
if [ -z "$num" ]; then
    echo 'ERROR: No number to compare against; pass -g|--greater|-s|--smaller|-lt|-le|-eq|-ne|-ge|-gt N'
    echo
    printUsage "$0"
    exit 2
elif [ ${#commands[@]} -gt 0 -a $# -gt 0 ]; then
    echo 'ERROR: Cannot combine COMMAND(s) with reading FILE(s) / input.'
    echo
    printUsage "$0"
    exit 2
fi >&2

countInput()
{
    wc "${wcArg[@]}" -- "$@"
}

getCount()
{
    if [ ${#commands[@]} -gt 0 ]; then
	eval "${commands[@]}" | countInput
    else
	countInput "$@"
    fi
}
getTeedCount()
{
    if [ ${#commands[@]} -gt 0 ]; then
	eval "${commands[@]}"
    else
	cat -- "$@"
    fi | \
	tee /dev/fd/3 | countInput
}
count=$($counter "$@") || exit 4

count="${count% *}" # Drop any FILE names that wc appends.
[ $count $compareOp $num ]
