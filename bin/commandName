#!/bin/bash

printUsage()
{
    cat <<HELPTEXT
Extract the name (without path) of the (first) executed command from the passed
COMMANDLINE.
With --eval, also supports interpolation via eval (basically, quoted commands).
If no command is found, returns "undefined" or what's passed via
--undefined UNDEFINED.
HELPTEXT
    printf 'Usage: %q %s\n' "$(basename "$1")" '[--eval] [--undefined UNDEFINED] [--] COMMANDLINE ... [-?|-h|--help]'
}
isEval=
undefined=undefined
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printUsage "$0"; exit 0;;
	--eval)		shift; isEval=t;;
	--undefined)	shift; undefined="$1"; shift;;
	--)		shift; break;;
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done


if [ "$isEval" ]; then
    literalReplacement="$undefined"
    literalReplacement="${literalReplacement//\\/\\\\}"
    literalReplacement="${literalReplacement//&/\\&}"

    # First eat individual preceding VAR=VAL arguments.
    while [[ "$1" =~ ^[[:alpha:]_][[:alnum:]_]+=(\\[[:space:]]|[^[:space:]\\])*$ ]]; do shift; done

    # Extract COMMAND from preceding VAR=VAL inside the first remaining
    # argument.
    readonly COMMAND_SEPARATOR_COLLECTION=';&|[:space:]'
    commandFilespec="$(printf '%s\n' "${1:-${undefined}}" | sed \
	-e "s/^[[:space:]]*\\([[:alpha:]_][[:alnum:]_]\\+=\\(\\\\[[:space:]]\\|[^[:space:]\\\\]\\)*[[:space:]]\\+\\)*\\(\"\\([^\"]\\+\\)\"\\|'\\([^']\\+\\)'\\|\\([^${COMMAND_SEPARATOR_COLLECTION}]\\+\\)\\)\\([${COMMAND_SEPARATOR_COLLECTION}].*\\)\\?$/\\4\\5\\6/" \
	-e t \
	-e "s#.*#${literalReplacement//#/\\#}#" \
	-e q
    )"
else
    while [[ "$1" =~ ^[[:alpha:]_][[:alnum:]_]+= ]]; do shift; done
    commandFilespec="${1:-${undefined}}"
fi
basename -- "$commandFilespec"
