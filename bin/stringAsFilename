#!/bin/bash
shopt -qs extglob

printUsage()
{
    cat <<HELPTEXT
Encode arbitrary TEXT (or text read from stdin via -) for use as a filename;
i.e. escape all forbidden characters, control the length, so that the result is
a valid filename but enough uniqueness is kept. The only guarantee is that the
same TEXT will always lead to the same filename.
HELPTEXT
    echo
    printf 'Usage: %q %s\n' "$(basename "$1")" '[--] TEXT [...] [-?|-h|--help]'
    printf 'Usage: cat FILE [...] | %q %s\n' "$(basename "$1")" '- [-?|-h|--help]'
}

while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printUsage "$0"; exit 0;;
	--)		shift; break;;
	-)		break;; # For supporting special - FILE without prior --
	-*)		{ echo "ERROR: Unknown option \"$1\"!"; echo; printUsage "$0"; } >&2; exit 2;;
	*)		break;;
    esac
done
if [ $# -ne 1 ]; then
    printUsage "$0" >&2
    exit 2
fi

if [ "$1" = '-' ]; then
    string=$(< /dev/stdin)
    [ -n "$string" ] || exit 1
else
    string=${1?}
fi


filename="${string//[^A-Za-z0-9]/_}"
filename="${filename//+(_)/_}"
filename="${filename#_}"
filename="${filename%_}"
if [ ${#filename} -lt 8 -o ${#filename} -gt 64 ]; then
    # Too short is bad because there's not enough uniqueness; too long makes for
    # hard to read filenames. Solve both by using the hash of the original
    # command.
    printf %s "$*" | sha256sum - | cut --delimiter ' ' --fields 1
else
    printf '%s\n' "$filename"
fi
