#!/bin/bash
shopt -qs extglob

printUsage()
{
    cat <<HELPTEXT
Query the user with READ-ARGS (e.g. -n 1 -p 'Type letter: ') from the terminal,
until the pressed key matches the VALID-RESPONSE-GLOB (e.g. '[a-z]|.') or it
times out.
HELPTEXT
    echo
    printf 'Usage: choice="$(%q %s)"\n' "$(basename "$1")" '-v|--valid VALID-RESPONSE-GLOB [-k|--keep-prompt] [READ-ARGS ...]'
}

printfToTerm()
{
    { printf >/dev/tty "$@"; } 2>/dev/null
}

isKeepPrompt=
hasCharLimit=
isEcho=t
validResponseGlob=
typeset -a promptText=()
typeset -a readArgs=()
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	shift; printUsage "$0"; exit 0;;
	--valid|-v)	shift; validResponseGlob="$1"; shift;;
	--keep-prompt|-k)
			shift; isKeepPrompt=t;;

	-+([ers]))	readArgs+=("$1")
			case "$1" in
			    *s*)    isEcho=;;
			esac
			shift
			;;
	-[ditu])	readArgs+=("$1" "$2"); shift; shift;;
	-[nN])		readArgs+=("$1" "$2"); hasCharLimit=t; shift; shift;;
	-p)		shift; promptText=("$1"); shift;;
	*)		break;;
    esac
done
if [ -z "$validResponseGlob" ]; then
    printUsage "$0" >&2
    exit 2
fi

if [ "$isKeepPrompt" ]; then
    if [ "$hasCharLimit" ] || [ ! "$isEcho" ]; then
	afterPromptSequence=$'\n'   # The user doesn't provide the newline (or it isn't echoed); we have to.
    fi
else
    if [[ ${#promptText[@]} -gt 0 && ( ${#promptText[0]} -gt ${COLUMNS:-80} || "${promptText[0]}" =~ $'\n' ) ]]; then
	# The prompt spans multiple terminal lines; need to determine how many to be
	# able to completely clear them.
	numLines=$(printf '%s' "${promptText[0]}" | nowrap --wrap | wc -l)
	if [ ! "$hasCharLimit" ] && [ "$isEcho" ]; then
	    # Add one for the new line created by concluding the input with Enter.
	    let numLines+=1
	fi
	afterPromptSequence="[$((${numLines:-2} - 1))F[0J" # Return cursor to the beginning of the previous $numLines lines and clear to end of screen.
    elif [ "$hasCharLimit" ] || [ ! "$isEcho" ]; then
	afterPromptSequence='[1G[2K' # Return cursor to the beginning of the current line and clear it.
    else
	printfToTerm '\n%s' '[1F[s'   # Scroll if necessary for the new line created by concluding the input with Enter, go back to previous line and save the position.
	afterPromptSequence='[u[0J' # Restore position and clear until the end of the terminal.
    fi
fi

status=0
while :
do
    choice="$(userquery "${readArgs[@]}" ${promptText:+-p} "${promptText[@]}" "$@")" || { status=$?; break; }

    case "$choice" in @($validResponseGlob)) printf '%s\n' "$choice"; break;; esac

    if [ "$hasCharLimit" ] || [ ! "$isEcho" ]; then
	promptText=()
    elif [ ! "$isKeepPrompt" ]; then
	printfToTerm %s "$afterPromptSequence"
    fi
done
printfToTerm %s "$afterPromptSequence"
exit $status
