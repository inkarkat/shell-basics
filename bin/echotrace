#!/bin/bash

: ${ECHOTRACE_IFS=' '}
[ "$ECHOTRACE_IFS" = newline ] && ECHOTRACE_IFS=$' \\\n  '

printUsage()
{
    cat <<HELPTEXT
Write arguments (separated by a space or \$ECHOTRACE_IFS) as an execution trace
(i.e. with \$PS4 prepended and indicating the nesting level) to standard error /
ECHOTRACE_TRACEFILE, like "set -x" would do (but without the execution).
With --eval, the evaluation result will be printed instead of the (quoted) eval.
HELPTEXT
    printf 'Usage: [ECHOTRACE_IFS=STRING|newline] [ECHOTRACE_TRACEFILE=FILESPEC|&N] %q %s\n' "$(basename "$1")" '[--eval] [--] [ARG ...] [-?|-h|--help]'
}
isEval=
case "$1" in
    --help|-h|-\?)	shift; printUsage "$0"; exit 0;;
    --eval)		shift; [ "$1" = eval ] && isEval=t;;
    --)			shift;;
esac
[ $# -eq 0 ] && exit

case "$ECHOTRACE_TRACEFILE" in
    '')		exec 3>&2;;
    \&[0-9])	eval "exec 3>$ECHOTRACE_TRACEFILE";;
    ?*)		exec 3>>"$ECHOTRACE_TRACEFILE";;
esac

# Duplicated to ../../verbose/bin/verbose
nestingPrefix=
if [ $SHLVL -gt 3 ]; then
    nesting="${PS4:0:1}"
    printf -v nestingPrefix "%$((SHLVL - 3))s" "${PS4:0:1}"; printf -v nestingPrefix %s "${nestingPrefix// /${PS4:0:1}}"
fi
tracePrefix="${nestingPrefix}${PS4:-\$ }"

ECHOTRACE_IFS="${ECHOTRACE_IFS//$'\n'/$'\n'${tracePrefix}}"

if [ "$isEval" ]; then
    shift
    joinBy >&3 --prefix "${tracePrefix}" -- "$ECHOTRACE_IFS" "$@"
    exit
fi

# Duplicated to +/\$isQuoted timestamp
# Duplicated to ../../shell-scripting/bin/argsToArgs
# Duplicated to ../../verbose/bin/verbose
quotedArgs=
for arg
do
    # Enclose in single quotes if it contains special characters (but not
    # non-space whitespace), and does not solely consist of that special
    # character (then, it's shorter to escape: \( vs. '(').
    if [[ "$arg" =~ [][$\ \`\"?\*{}()\&\;\!~] ]] && [[ ! "$arg" =~ [$'\n\r\t\v'] ]] &&  [ ${#arg} -gt 1 ]; then
	if [[ "$arg" =~ \' ]]; then
	    # Decide based on length whether to .\ \ \'\ \ . or '   '\''  .'
	    printf -v sqArg %s "'${arg//\'/\'\\\'\'}'"
	    sqArg="${sqArg#\'\'}"; sqArg="${sqArg%\'\'}"    # Empty '' at the beginning and end can be removed.
	    printf -v arg %q "$arg"
	    [ ${#sqArg} -lt ${#arg} ] && arg="$sqArg"
	else
	    printf -v arg %s "'${arg//\'/\'\\\'\'}'"
	fi
    else
	printf -v arg %q "$arg"
    fi
    quotedArgs+="${quotedArgs:+${ECHOTRACE_IFS}}${arg}"
done

printf >&3 '%s%s\n' "$tracePrefix" "$quotedArgs"
